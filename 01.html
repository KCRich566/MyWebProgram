<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        .pink {
            background-color: pink;
        }
    </style>
</head>

<body>
    <div>123</div>
    <div class="box">123</div>
    <div class="box">abc</div>




    <!--
    [MDN網站]
    JavaScript 組成:
        1. ECMAScript: 規定JS基礎語法核心
        2. Web APIs -
            1. DOM: 頁面文檔對象模型
            2. BOM: 瀏覽器對象模型
    -->

    <button class="pink">按鈕1</button>
    <button>按鈕2</button>
    <button>按鈕3</button>
    <button>按鈕4</button>
    <script>
        // 因為執行是由上往下，所以比較建議JS寫在Body尾端。
        // alert()與Prompt會跳過頁面渲染先被執行
        // <script src=''/>

        // 如果document write再載時使用，會直接append在網頁後端。
        // 但如果是在載入後觸發，則會覆蓋原先的document

        // var 可以先使用在聲明
        // var 可以重複聲明
        // var 沒有塊級作用域

        // let 不能重複聲明
        // let 用來解決var的問題
        // let 有塊級作用域

        const PI = 3.1415926
        let pi = PI;
        pi = 2;
        // basic: 弱數據類型，當賦值後才知道是什麼數據類型
        //  number
        //  string: "", '', ``反引號. 拼接:字串與字串的拼接，字串與數字的拼接
        //  boolean
        //  undefined: 尚未賦值 
        //  null: let obj = null，表示賦值了，但為空。是一中object. 也就是 let obj = {}
        // reference: 
        //  object 
        //  function
        //  array

        // 跳脫字元 \ 

        // "${variable}" 模板字符串

        //類型轉換
        //  隱式轉換: 
        // 如字串與數字相加(+)，會將數字轉為字串來拼接
        // 如數字與字串相減乘除(-*/)，會將字串轉為數字來計算
        //  顯示轉換
        //      Number() 
        //      parseInt('12px') 只取數字
        //      parseFloat('12.1px')


        // === 表示數值與類型都相同的比較
        // !== 表示數值或類型不相同的比較
        let a = 0
        let b = '0'
        console.log(a == b) // 比較運算符號也會有隱式轉換喔
        console.log(a === b)
        console.log(NaN === NaN) // NaN不等於任何型別與數值
        console.log(parseInt('122ss12'))
        console.log(Number('100') + Number('200'))
        console.log('undefined + 1 = ', undefined + 1, 'typeof = ', typeof (undefined + 1))
        console.log('null + 1 =    ', null + 1, 'typeof = ', typeof (null + 1))

        let t;
        document.write('出', pi, t, '');
        let multitypeArray = ['test', 12]
        multitypeArray[2] = 5;
        multitypeArray[3] = '';
        multitypeArray[4] = NaN;
        multitypeArray[5] = undefined;
        multitypeArray[6] = undefined;
        // 從前最前端插入
        multitypeArray.unshift("first");
        // 從最後端插入
        multitypeArray.push("last")
        multitypeArray.splice(4, 1);
        multitypeArray.pop();
        multitypeArray.push("last")

        let arr = [5, 1, 3, 4, 6, 2];
        arr.sort(function (a, b) {
            // 生冪排列
            return a - b;
            // 降冪排列
            // return a+b;
        })

        // (不推薦)如果變數沒有聲明，但直接賦值，會直接變成var
        for (let i = 0; i < multitypeArray.length - 1; i++) {
            console.log('i = ', i, '  array:', multitypeArray[i]);
        }
        console.log(multitypeArray[0], multitypeArray[1], multitypeArray[2])
        console.log('Length:', multitypeArray.length, 'data:', multitypeArray);

        alert('你好,JS~');
        let age = 32;
        age = 33;
        let bts = document.querySelectorAll('button');
        for (let i = 0; i < bts.length; i++) {
            bts[i].addEventListener('click', function () {
                document.querySelector('.pink').className = '';
                this.className = 'pink';
                console.log(this.innerHTML)
                let content = prompt('請輸入要顯示的內容')
            })
        }

        // 匿名函數
        // 函數表達式
        let fn = function () {
            let test = 3 + 64
            return test;
        }
        console.log("test:", fn(), " function:", fn);

        // 立即執行的函數
        // (function(){}  ())
        (function () {
            let num = 20;
        })();

        // 邏輯中斷
        // 邏輯左邊有數值x || y就執行x跳過y，否則執行y.
        // 反之: x && y, 如果x = false則不執行y;
        function ff(x, y) {
            // 類似於參數初始化->function ff(x = 0 , y = 0)的初始化
            x = x || 0;
            y = y || 0;
            console.log(x + y);
        }

        // Boolean, '', 0, false, null, undefined, NaN
        // null + 1 = 1
        // NaN + 1 = NaN (NaN與其他運算永遠為NaN)





        // 對象(無序)
        let object = new Object();
        let obj = {
            'my-test': "test",
            uname: 'user',
            gender: 'woman',
            age: 30,
            fn1: function () {
                return 1;
            },
            fn2: function () {
                return 2;
            }
        }
        console.log('obj=', obj);
        console.log('fn2=', obj.fn2());
        obj.test = true;
        delete obj.fn2;
        console.log(obj)
        // 如果屬性Key是String就需要用以下的查詢方式
        console.log(obj['my-test']);

        // 遍歷一個對象
        for (let i in obj) {
            console.log(i, '=', obj[i]);
        }

        let students = [
            { name: 'A', age: 18, gender: 'girl' },
            { name: 'B', age: 19, gender: 'boy' },
            { name: 'C', age: 20, gender: 'girl' },
            { name: 'D', age: 21, gender: 'boy' },
        ]

        for (let i in students) {
            console.log(students[i]);
            students[i].name = i + 1;
        }


        // 值數據類型(值) - string, number, boolean, undefined, null - stack(棧) -> let 可以轉 const
        // 引用數據類型(址) - Object, Array, Date - heap(堆) -> const 可以轉 let (因為地址不變)



        // var
        // let
        // const 盡量優先使用此宣告，因為語意化更好，如果發現後面會被修改，再改為let就好
        let numlet = 4;
        const numconst = numlet;
        console.log(numlet)
        console.log(numconst)

        const arrayconst = [1, 2, 3, 4];
        let arraylet = arrayconst;
        arraylet.push(5);
        console.log(arrayconst)
        console.log(arraylet)

        // Web API主要在修改DOM,BOM
        // DOM 是文檔對象類型 - 操作網頁內容與實現用戶交互
        // DOM tree - 樹狀的HTML定義，Root為document(最大的對象) -> HTML -> (head, body) ，顯示標籤與標籤之間的關係
        // DOM 對象: 瀏覽器根據HTML標籤生成JS對象，每個對象都有屬性與標籤。如下
        const div = document.querySelector('div');
        console.dir(div);

        // 獲取DOM元素
        // 1. 根據CSS選擇器來選擇
        // 選擇匹配的第一個元素
        document.querySelector('CSS選擇器');
        // 取得的是NodeList，並沒有增刪改查功能的陣列(偽陣列)
        const allbox = document.querySelectorAll('.box');
        console.log(allbox);
        for (let i = 0; i < allbox.length; i++) {
            console.log(allbox[i]);
        }
        // 2. 其他獲取元素方式(舊的)
        // document.getElementById('ID');
        // document.getElementByTagName('div');
        // document.getElementByClassName('w');

        // 修改元素內容
        // 對象.innerText: 放入簡單值(忽略HTML結構)
        // 對象.innerHTML: 放入HTML格式

        // 操作元素常用屬性
        // href, title, src


        // 操作元素樣式屬性
        // 1. 使用style屬性操作CSS
        div.style.height = "200px";
        div.style.paddingLeft = '20px';
        div.style.border = "2px solid hotpink ";
        document.body.style.backgroundColor = "#f1a10d";

        // 2. 使用className操作CSS
        // 先用Class來定義CSS樣式
        // 再用 div.className = "CSS定義的Class樣式(box box2)"
        // 如div.className = 'box1 box2';
        // 注意:會覆蓋原先的類唷

        // 3. 使用classList操作類控制CSS，用來處理第二項會覆蓋先前類別的問題
        div.classList.add('class1');    // 新增
        div.classList.remove('class1'); // 刪除
        div.classList.toggle('class1'); // 切換
    </script>

    <!--表單-->
    <input type="text" value="電腦">
    <input type="checkbox" value="電腦" checked>
    <button disabled="disabled">eqwwewe</button>


    <script>
        // 操作表單元素
        // 表單.value = '用戶名'
        // 表單.type = 'password'
        const uname = document.querySelector('input');
        // 表單的值，只能透過value獲得
        console.log('uname.value=', uname.value);
        console.log('uname.innerHTML=', uname.innerHTML)
        console.log('uname.innerText=', uname.innerText)
        const checkbox = document.querySelector('input[type=checkbox]');
        checkbox.checked = false;
    </script>

    <!-- 自定義屬性 
    以data-"" 開始的屬性為自訂義屬性
    如此一來可以使用component.dataset.屬性來取得值
    -->
    <div class="ppo" data-id="11">1</div>
    <div class="ppo" data-id="22" data-smi="yes">2</div>
    <div class="ppo" data-id="33">3</div>
    <div class="ppo" data-id="44">4</div>
    <div class="ppo" data-id="55">5</div>
    <script>
        const one = document.querySelector(".ppo");
        console.log(one.dataset.id, one.dataset.smi)
        console.log(one.dataset)
    </script>

    <script>
        // 定時器-間歇函數
        let interval = function () {

        }
        function interval_2() {
            // clearInterval(timer1)
            return;
        }
        let timer1 = setInterval(interval_2, 1000)
        console.log("time: ", timer1);
        clearInterval(timer1)
    </script>

    <!-- 事件監聽 -->
    <script>

        //1.(舊) 元件.on事件 = function(){}
        //2. 元素對象.addEventListener('事件類型', function(){}); 此方法可以重複綁定
        // 鼠標事件: click, mouseover, mouseleave
        // 焦點事件: focus, blur(失去焦點)
        // 鍵盤事件: keydown, keyup
        // 文本事件: input
    </script>

    <!-- 事件對象: 既然是對象一定會有屬性與方法
        主要存取事件信息，如鼠標事件觸發時的位置.默認在function的第一個參數
       -->

    <button>Click</button>
    <script>
        const btn = document.querySelector('button');
        btn.addEventListener('click', function (e) {
            // e. 
            // type
            // clientX, clientY 鼠標位置: 獲取鼠標相對於瀏覽器的位置
            // offsetX, offsetY: 獲取鼠標相對於當前DOM元素上的位置
            // key="Enter"
        });
    </script>


    <!-- 環境對象(this) 
他代表當前執行所使用的環境
[誰調用，誰是this]
-->

    <script>
        function fsn() {
            console.log(this)
        }
        btn.addEventListener('click', function (e) {
            this.style.color = 'red';
        })
        // window.fn(): 普通function內的this是指向window
        // 事件監聽: 但this會在函數的調用者間切換。
    </script>


    <!-- 回調函數 
     將函數A當作函數B的參數傳遞，我們成A為回調函數
     -->

    <script>

        function fssn() {
            console.log('我是回調函數');
        }
        setInterval(fn, 1000);
    </script>


    <!-- 事件流 
        A -> B -> C -> Target -> C -> B -> A 
        (   捕獲階段  )         (  冒泡階段(大部分用這個)  )
        捕獲階段: document -> element HTML -> element Body -> element div 
        冒泡階段: element div -> element Body -> element HTML -> document
        document.addEventListener(type, name, 是否使用捕獲機制)

        Level0事件沒有捕獲唷(on事件)
        Level2事件的第三個參數是預設為false使用冒泡模式

        阻止冒泡: 阻止冒泡與捕獲 即阻止事件流
        事件對象.stopPropagation()

        
        事件解綁定
        1. (Level0)將on事件 = null 即可.
        2. (Level2)使用removeEventLintener('事件名稱', 函數名)
        hint 匿名函數無法解除綁定喔


        鼠標事件:
        mouseover, mouseout會有冒泡效果
        mouseenter, mouseleave 沒有冒泡效果(推薦)

        
    -->
    <style>
        .father {
            height: 500px;
            width: 500px;
            background: #000;
        }

        .son {
            width: 200px;
            height: 200px;
            background: #a0b0d0;
        }
    </style>
    <div class="father">
        <div class="son"></div>
    </div>
    <script>
        const father = document.querySelector('.father');
        const son = document.querySelector('.son');
        document.addEventListener('click', function () {
            alert('我是爺爺')
        }, false);
        father.addEventListener('click', function (e) {
            alert('我是爸爸')
            //阻止傳播，看怎麼流，第三個參數會導致啟動不同

            e.stopPropagation()
        }, false);
        son.addEventListener('click', function (e) {
            alert('我是兒子')

        }, false);
    </script>

    <!-- 事件委託(冒泡效果其實也不錯):
        1. 漸少註冊次數

        以下程式碼，點到ul就會被執行事件
     -->
    <ul>
        <li>第1個孩子</li>
        <li>第2個孩子</li>
        <li>第3個孩子</li>
        <li>第4個孩子</li>
        <li>第5個孩子</li>
        <p>不要變色歐</p>
    </ul>
    <script>

        const ul = document.querySelector('ul');
        ul.style.cursor = 'pointer';
        ul.addEventListener('click', function (e) {
            // 要知道點到哪個子元素
            // (target 會顯示最後點到的對象)
            if (e.target.tagName === "LI") {

                e.target.style.color = 'red';
            }
        })
    </script>

    <!-- 阻止默認行為 
     使用preventDefault-->
    <form action="http://www.baidu.com">
        <input type="submit" value="免費註冊">
    </form>
    <a class="defaultA" href="http://www.baidu.com">百度一下</a>
    <script>
        const form = document.querySelector('form');
        form.addEventListener('submit', function (e) {
            // 這樣就不會執行action
            e.preventDefault();
        })
        const aa = document.querySelector('.defaultA');
        aa.addEventListener('click', function (e) {
            e.preventDefault();
        })
    </script>


    <!-- 其他事件

      A. 頁面加載事件: 主要是要等頁面資源加仔完成後才執行的事情。
      如Script在head中，就時常需要使用此方法
      1. [windows] load event: 頁面加載完所有資源與外部才執行
      2. [document] DOMContentLoaded event: DOM被建立時就加載
     -->
    <script>
        window.addEventListener('load', function () {
            // 撰寫載button宣告之前，但實際執行是在load結束後
            const btn = document.querySelector('.loadButton');
            console.log('btn=', btn.offsetTop);
        })
    </script>
    <button class="loadButton"></button>
    <!-- 其他事件  scroll event
       B. 元素滾動事件: 有滾動才顯示的，或是滾動到某個位置才顯示
       [windows, document] scroll event 
        -->
    <script>
        window.addEventListener('scroll', function (e) {
            console.log('我滾動');
            console.log(window);
            // div 叫做scrollTop, scrollLeft 顯示頭部
            console.log('scrollX=', window.scrollX)
            console.log('scrollY=', window.scrollY)
        })

        console.log('document=', document);
        console.log('document.documentElement=', document.documentElement);
    </script>

    <!-- 其他事件
       [window, document]scroll
       [window, document] resize
       [div] clientWidth, clientHeight(不包含Border) 
       
       window.devicePixelRatio || 1
       
       document.documentElement: 整個窗體
       document.documentElement.clientWidth
       document.documentElement.scrollTop
       

       獲取自己離父元素多遠
       offsetTop, offsetTop
       

       getboundingClientRect(): 返回元素的大小與其相對視口位置
       -->



    <!-- Window對象:
        BOM(Broser Object Model, 瀏覽器對象模型): BOM(整個瀏覽器)打開DOM(HTML顯示區域)
            window(最大對象) -> (navigator, location, document, history, screen)
            document -> HTML -> (head, body)
        定時器-延遲函數
        JS執行機制
        location對象
        navigator對象
        history對象
       -->
    <script>
        //window.document.querySelector(): window可以忽略
        console.log('window === window.document = ', window === window.document);

        // function也會變成window的方法
        function fnn() {
            console.log(1);
        }
        window.fnn();
        var num = 10; // 所有透過var定義的屬性與方法，都會變成window的屬性與方法
    </script>
    <!-- 定時器-延時函數(到位...就結束囉，即只會執行一次): 如全屏廣告，出現一次就不再出現 -->
    <!-- 延遲函數: setTimeout(fn, 等待的毫秒數), clearTImeout() -->
    <!-- 間歇函數: setInterval(fn, 間隔的毫秒數), clearInterval()-->
    <script>
        let timer = setTimeout(function () {
            console.log('時間到了')

        }, 2000);
        console.log('timer id = ', timer);
        // clearTimeout(timer); 
    </script>
    <!-- JS執行機制 
    最大特點是 單線程，同一個時間只可以做一件事，像是setTimout為0秒，仍不會先被執行。因為要先等待同步任務完成 

    同步: 前一個任務執行完才會執行後一個任務: (JS沒有這東西唷，但類似)有個執行棧
    異步: 同時執行: 通過回調函數實現的: (JS沒有這東西唷，但類似)有個任務對列(也稱消息對列)
        當異步任務結束後，會透過回調函數進入消息對列。主線程再從消息對列取出資料。
        1. 普通事件: click, resize
        2. 資源加載: load, error
        3. 定時器: setInterval, setTimeout

    一旦執行棧中的同步任務執行完畢，系統就會一次讀取任務對列中的異步任務
    那一步任務在哪裡執行呢? Ans: 瀏覽器，因為瀏覽器可以處理多線程操作，但JS只能是單線程
    在瀏覽器執行的有異步WebAPI, AJAX, DOM, setTimout, setInterval
    
    事件循環Event loop: 由於主線程不斷的重複獲得任務、執行、再獲取任務、再執行的機制
    -->
    <script>
        console.log(1);
        console.log(2);
        setTimeout(function () {
            console.log(3);

        }, 2000)
        console.log(4);

    </script>


    <!-- location對象: 網址類 -->

    <a class="trans" href="http://www.itcast.cn">支付成功，<span>60</span>秒後跳轉到首頁</a>
    <script>

        console.log(window.location);
        console.log(location)
        console.log(location.href)
        // 經常用href的JS方式來跳轉頁面
        const a_trans = document.querySelector('.trans');
        num = 9999;
        setInterval(function () {
            num--;
            a_trans.innerHTML = ``;
            a_trans.innerHTML = `支付成功，將在${num}秒後跳轉至首頁`;
            if (num === 0) {
                clearInterval();
                location.href = "http://www.itcast.cn";
            }
        }, 1000)
    </script>

    <form action="">
        <input type="text" name="uername">
        <input type="password" name="pwd">
        <button type="submit">submit </button>
    </form>
    <a href='#/my'>我的</a>
    <a href='#/friend'>朋友</a>
    <button class="reload">Reload</button>
    <script>
        //submit按下後location.search可以取得[get]form的內容
        console.log('location.serach = ', location.serach);
        // 獲取'#'號後面的值，減少頁面載入的資源
        console.log('location.hash', location.hash);

        const reload = document.querySelector('.reload');
        reload.addEventListener('click', function () {
            location.reload(); //相當於按下F5
            //reload(true) 參數給true表示強制刷新
        });
    </script>
    <!-- navigator  : 瀏覽器相關信息
    userAgent: 檢測瀏覽器版本與平台 
    -->
    <!-- history: 使用在瀏覽器的上一頁與下一頁的功能
      -->
    <div>
        <button class="control">prev</button>
        <button class="control">next</button>
    </div>
    <script>
        // 使用first-child一定要確保有父節點
        const back = document.querySelector('button.control:first-child')
        console.log('back = ', back);
        const next = back.nextElementSibling;
        back.addEventListener('click', function () {
            // 以下兩者一樣
            //history.back();
            history.go(-1);
        });
        next.addEventListener('click', function () {
            // 以下兩者一樣
            //history.forward();
            history.go(1);

        });

    </script>

    <!-- 本地存儲 : 只能存字符串喔
    1. 存在瀏覽器中
    2. session storage, local storage約5MB
        local storage可以多窗口共享，已鑑值的方式儲存。只能儲存字符串類型喔
        session storage與local storage一樣，只是生命週期時當流覽器關閉時結束
    -->
    <script>
        // window.localStorage.setItem(key,value)
        // window.sessionStorage

        localStorage.setItem('uname', 'Ken');
        localStorage.setItem('age', 20);

        console.log('localStorage.getItem(\'uname\') = ', localStorage.getItem('uname'));
        console.log('localStorage.getItem(\'age\') = ', localStorage.getItem('age'), typeof (localStorage.getItem('age')));

        localStorage.setItem('uname', 'Ted');

        console.log('localStorage.getItem(\'uname\') = ', localStorage.getItem('uname'));


        const objs = {
            uname: 'K',
            age: 15,
            gender: '女'
        }
        //localStorage.remove('uname');

        //localStorage.clear();


        // 不能直接存obj對象
        localStorage.setItem('objs', objs);
        console.log('localStorage.getItem(\'objs\') = ', localStorage.getItem('objs'));
        //需要先轉換成json字串
        localStorage.setItem('objjson', JSON.stringify(objs));
        console.log('localStorage.getItem(\'objjson\') = ', localStorage.getItem('objjson'));
        console.log('localStorage.getItem(\'objjson\')[\'uname\'] = ', JSON.parse(localStorage.getItem('objjson'))['uname']);

    </script>


    <!-- 正規表達式
        表單驗證，敏感詞偵測
        const reg = /正規式/
        正規式 元字符: 
            邊界符: ^開始  $結尾
            量詞: 
                *重複零次或多次 
                +重複一次或多次 
                ?重複零次或一次 
                {n}重複n次 
                {n,}重複n次一上 
                {n,m}重複n~m次
            字符類: 
                \d: 相當於[0-9]
                \D: 相當於[^0-9/] 
                \w: 相當於[a-zA-Z0-9_]
                \W: 相當於[^a-zA-Z0-9_]
                \s: 匹配空格(包括換行符號,制表符,空格符) 相當於[\t\r\n\v\f]
                \S: 相當於[^\t\r\n\v\f]
                []匹配字符集的集合: [abc]包含其中元素即可, [a-zA-Z0-9]
                [^]以上取反,表示不包含: [^abc], [^a-z]
                . 匹配除了換行符衣外的單個字符
            修飾符: 在正規表達是後面的符號 /表達式/修飾符號
                i: ignore不區分大小寫
                g: global全局匹配，預設只抓取第一次匹配的內容
                
            (abc|cba): 指匹配abc或cba的字詞
        reg.test("a string"): 是否匹配
        reg.exec("a string"): return a array
-->
    <script>
        // 正規表達式的變數，使用兩個斜線包裹
        const str = '我在學習前端，希望學習前端能高薪畢業'
        const reg = /前端/
        let isMatch = reg.test(str)
        console.log('reg.test(str) = ', isMatch, ' typeof(reg) = ', typeof (reg));
        let matchArr = reg.exec(str);
        console.log('reg.exec(str) = ', matchArr, ' typeof(reg) = ', typeof (reg));

        //用戶名驗證
        const username = /^[a-zA-Z0-9-_]{6,16}$/;
        //日期格式
        const date = /^\d{4}-\d{1,2}-\d{1,2}/;

        const str2 = 'java是一門編成語言,學完java工資很高'
        console.log("str2.replace(/java/i, '前端') = ", str2.replace(/java/i, '前端'));
        console.log("str2.replace(/java/i, '前端') = ", str2.replace(/java/ig, '前端'));

    </script>
    <!--作用域鏈: 就是塊級或函數級變量的取得方式 -->

    <!-- GC 垃圾回收機制:
        1. 全局變量不會回收(但關閉葉面會回收)
        2. 局部變量會被自動回收

        內存洩漏: 內存由於某種原因未釋放或無法釋放

        1. 棧: 操作系統自動分配與釋放
        2. 堆: 由垃圾回收機制回收
            1. 引用計數(瀏覽器少用了): 查詢對象沒人引用，就回收: const arr = [1,2]; arr = null;
                1.1 嵌套引用的話會無法釋放(內存洩漏): let o1 = {}; let o2 = {}; o1.a = o2; o2.a = o1;
            2. 標記清除法: 只要從根部(全局變量)開始，找不到的會直接被回收
      -->

    <!-- 閉包 Closure: 內層函數 + 外層函數的變量 -> 外部也可以使用函數內部的變量
        // 可以實現數據的私有，以防止被直接輕易地修改
        function outer(){
            // ----閉包在這----
            const a = 1;
            function inner(){
                console.log(a);
            }
            // ---------------
            return inner;
        }  
        let fnn = outer();
        fnn();


      -->
    <script>
        // 將fnnn = outer() 放在全局。很有用。且不會被回收
        // 也可以成為內存洩漏，但這是預期的 
        let iiii = 0;
        function outer() {
            let i = 0;
            function inner() {
                i++;
                console.log(`inner第${i}次被呼叫`);
            }
            return inner;
        }
        let fnnn = outer();
        fnnn();
        fnnn();
        fnnn();
    </script>

    <!-- 變量提升: var 在其他地方被宣告時，會直接被放置在當前作用域的頭(指提升聲明，不會賦值)，使之成為全局變數 -->
    <!-- 函數提升: 與var一樣，在聲明之前調用。他會將函數所有聲明放在當前作用域的最前方 -->
    <!-- 函數參數:
       1. 動態參數: getSum(a, b, c ....){};
       2. 剩餘參數: getSum(a,b, ...arr){};
        -->
    <script>
        // 動態參數: 只存在函數裏頭的arguments來製作
        function getSum() {
            // arguments 是偽數組. 不可以push, pop
            console.log(arguments);
            let sum = 0;
            for (let i = 0; i < arguments.length; i++) {
                sum += arguments[i];
            }
            console.log('sum = ', sum);
        }
        getSum(1, 2, 3, 4, 5);

        //剩餘參數(只有最末位的參數可以使用)
        // ...arr是一個展開運算符號
        function getSum2(...arr) {
            // arr 是真數組. 可以push, pop
            console.log('arr = ', arr);
        }
        getSum2(1, 2, 3, 4, 5);

        // ...arr是一個展開運算符號
        arr3 = [1, 2, 3];
        console.log('未使用展開運算符號', Math.max(1, 2, 3));
        console.log('使用展開運算符號', Math.max(...arr));
        // 展開運算符
        console.log('...arr', ...arr);
        // 合併運算符
        let arr4 = [...arr];
        console.log('arr4', arr4);

    </script>
    <!-- 箭頭函數: 目的是代碼可以更簡潔，並且不綁定this。
     用來替代原本需要匿名函數的地方
     箭頭函數有剩餘參數,但沒有動態參數喔 
     
     作用域不會自行創建this, 只會從作用域鏈的上層來查找
     (誰呼叫，this就是誰)
     
     不太推薦在此函數使用this,因為容易混淆
     -->

    <script>
        const fnnnn = function () {
            console.log(123);
        }
        // 箭頭函數
        const fnnnnn = (x, y) => {
            console.log(x + y);
            return x + y;
        }
        fnnnn(1, 2);

        // 如果只有一個參數可以省略括號，一行敘述句可以省略大括號，return也可以省略了
        const fnnnnnn = x => x * x;
        console.log(fnnnnnn(5));
        // 返回對象
        const fnnnnnnn = uname => ({ name: uname });
        console.log(fnnnnnnn(5));

    </script>

    <!-- 解構賦值
      1. 數組解構(將數組快速批量賦值給變量): const arr=[1,2,3]; const [a,b,c] = arr.
      2. 對象解構(將屬性與方法塊數賦值給變量): 屬性名與變量名要相同，也可以重新改名
       -->
    <script>
        // 數組解構
        let aaa = 1;
        let bbb = 2;
        [aaa, bbb] = [bbb, aaa];
        //防止undifined傳遞
        const [aaaa, bbbb = 0, ...cccc] = [1, 2, 3, 4, 5, 6];
        // 放棄3
        const [aaaaa, bbbbb = 0, , ccccc] = [1, 2, 3, 4];
        // 多為數組解構
        const [aaaaaa, [bbbbbb, cccccc]] = [1, [2, 3]];


        //對象解構
        const objjj = {
            uname2: 'Ken',
            age2: 18
        }
        const { uname2, age2 } = objjj;
        console.log(uname2, age2);

        // 改名
        const { uname2: uname3, age2: age3 } = objjj;

        // 數組對象
        const pig = [{uname: 'Ken', age:16},{uname: 'Ted', age:18} ];
        const [,{uname: u2, age:a2}] = pig;
        console.log(u2, a2);
    </script>
</body>

</html>